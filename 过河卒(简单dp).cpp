/**
  题目描述:
棋盘上 AA 点有一个过河卒，需要走到目标 BB 点。卒行走的规则：可以向下、或者向右。
同时在棋盘上 CC 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。
因此称之为“马拦过河卒”。
棋盘用坐标表示，AA 点 (0, 0)BB 点 (n, m)，同样马的位置坐标是需要给出的。
现在要求你计算出卒从 AA 点能够到达 BB 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

输入格式 :
一行四个正整数，分别表示 BB 点坐标和马的坐标。

输出格式:
一个整数，表示所有的路径条数。

样例1： 6 6 3 3  答案： 6；
**/

/** 
  思路： 判断该题为一个模拟型dp， dp[i][j]记录到这一点最多的路;
         就有： dp[i][j] = dp[i][j-1] + dp[i-1][j];
         要保证 j-1 和 i - 1 大于 0; 则预留一行一列，保证不溢出；
         另一个就是要有一个map题图， 判断能不能走；
         但是这里要注意，马最长可以跳两个横纵坐标即 x1-2 // y1-2存在， 为避免溢出，预留两行两列
         例如该题初始化：
          0 0 0 0 0 0 0 0 0
          0 0 0 0 0 0 0 0 0
          0 0 0 0 0 0 0 0 0
          0 0 0 0 1 0 1 0 0
          0 0 0 1 0 0 0 1 0
          0 0 0 0 0 1 0 0 0
          0 0 0 1 0 0 0 1 0
          0 0 0 0 1 0 1 0 0
          0 0 0 0 0 0 0 0 0
**/

//关键代码：
ans[2][2] = 1;
	for(int i = 2; i <= x; i ++){
		for(int j = 2; j <= y; j ++){
			if(mp[i][j] == 1){
				continue;
			}
			ans[i][j] = max(ans[i][j], ans[i-1][j]+ans[i][j-1]);
		}
	}

//具体代码：
#include<bits/stdc++.h>
using namespace std;
const int maxn = 100;
typedef unsigned long long LL;
bool mp[maxn][maxn] = {0}; //标记地图
LL ans[maxn][maxn]; // 记录到每个位置最多路子
int fx[9] = {0, 1, 1, -1, -1, 2, 2, -2, -2};
int fy[9] = {0, 2, -2, 2, -2, 1, -1, -1, 1};
int main()
{
	LL x, y, x1, y1;
	cin >> x >> y >> x1 >> y1;
	x += 2, y += 2, x1 += 2, y1 += 2;
	//初始化mp;
	for(int i = 0; i <= 8; i ++){
		if(x1+fx[i]>=0 && y1+fy[i]>=0){
			mp[x1+fx[i]][y1+fy[i]] = 1;
		}
	}
	ans[2][2] = 1;
	for(int i = 2; i <= x; i ++){
		for(int j = 2; j <= y; j ++){
			if(mp[i][j] == 1){
				continue;
			}
			ans[i][j] = max(ans[i][j], ans[i-1][j]+ans[i][j-1]);
		}
	}
	cout << ans[x][y] << endl;;
	return 0;
}
