/**
题目描述 ：
 观察下面的数字金字塔。
写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。
        7 
      3   8 
    8   1   0 
  2   7   4   4 
4   5   2   6   5 

在上面的样例中,从7→3→8→7→5 的路径产生了最大为：30

样例1：               答案1： 30
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5 
**/
/**
   思路： 观察数字金字塔，每个数字要么加上左下数， 要么加上右下数， 那么肯定要一个最大值；
          找个二维数组存下来，递推回去；
	  mp[i][j] = mp[i][j] + max(mp[i+1][j], mp[i+1][j+1]); 直接到mp上更新值；
**/
//具体代码
#include<bits/stdc++.h>
using namespace std;
int mp[1001][1001];
int main()
{
	int n;
	cin >> n;
	int m = 1;
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			cin >> mp[i][j];
		}
		++ m;
	}
	for(int i = n - 1; i >= 1; i --){
		for(int j = 1; j <= m; j ++){
			mp[i][j] = mp[i][j] + max(mp[i+1][j], mp[i+1][j+1]);
		}
		m --;
	}
	cout << mp[1][1] << endl;
	return 0;
}
